# P3: C++ SDK and Examples Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Complete C++ SDK implementation and create basic examples (Provider, Caller, PubSub) to demonstrate C++ language support.

**Architecture:**
- Complete C++ SDK with missing header files
- Implement Service side functionality
- Create basic examples for Provider, Caller, and PubSub
- Focus on core functionality, advanced features can be added later

**Tech Stack:**
- C++17 or later
- NATS C++ client (nats.cpp)
- CMake for build configuration

**Reference:** `sdk/cpp/`, Go SDK implementation

---

## Task 1: Complete C++ SDK Header Files

**Files:**
- Create: `sdk/cpp/include/lightlink/client.hpp`
- Create: `sdk/cpp/include/lightlink/service.hpp`
- Create: `sdk/cpp/include/lightlink/types.hpp`

**Step 1: Create client.hpp header**

```cpp
#pragma once

#include <string>
#include <functional>
#include <memory>
#include <map>
#include <vector>

namespace lightlink {

// TLS configuration
struct TLSConfig {
    std::string ca_file;
    std::string cert_file;
    std::string key_file;
    std::string server_name = "nats-server";
};

// Certificate discovery result
struct CertDiscoveryResult {
    std::string ca_file;
    std::string cert_file;
    std::string key_file;
    std::string server_name;
    bool found;
};

// Certificate discovery
CertDiscoveryResult discover_client_certs();
CertDiscoveryResult discover_server_certs();

// Message handler callback
using MessageHandler = std::function<void(const std::map<std::string, std::string>&)>;

// Client class
class Client {
public:
    Client(const std::string& url, const TLSConfig* tls_config = nullptr);
    ~Client();

    Client(const Client&) = delete;
    Client& operator=(const Client&) = delete;
    Client(Client&&) noexcept;
    Client& operator=(Client&&) noexcept;

    // Connection
    bool connect();
    void close();
    bool is_connected() const;

    // RPC
    std::map<std::string, std::string> call(
        const std::string& service,
        const std::string& method,
        const std::map<std::string, std::string>& args,
        int timeout_ms = 5000
    );

    // Pub/Sub
    void publish(const std::string& subject, const std::map<std::string, std::string>& data);
    std::string subscribe(const std::string& subject, MessageHandler handler);
    void unsubscribe(const std::string& subscription_id);

    // State Management (KV)
    void set_state(const std::string& key, const std::map<std::string, std::string>& value);
    std::map<std::string, std::string> get_state(const std::string& key);

private:
    struct Impl;
    std::unique_ptr<Impl> impl_;
};

} // namespace lightlink
```

**Step 2: Create service.hpp header**

```cpp
#pragma once

#include <string>
#include <functional>
#include <memory>
#include <map>

namespace lightlink {

// Forward declarations
class ServiceImpl;

// RPC handler callback
using RPCHandler = std::function<std::map<std::string, std::string>(
    const std::map<std::string, std::string>&
)>;

// Service class
class Service {
public:
    Service(
        const std::string& name,
        const std::string& nats_url,
        const TLSConfig* tls_config = nullptr
    );
    ~Service();

    Service(const Service&) = delete;
    Service& operator=(const Service&) = delete;
    Service(Service&&) noexcept;
    Service& operator=(Service&&) noexcept;

    // Register RPC methods
    void register_method(const std::string& method, RPCHandler handler);

    // Lifecycle
    bool start();
    void stop();
    bool is_running() const;

    // Get service name
    const std::string& name() const { return name_; }

private:
    std::string name_;
    std::unique_ptr<ServiceImpl> impl_;
};

} // namespace lightlink
```

**Step 3: Create types.hpp header**

```cpp
#pragma once

#include <string>
#include <map>
#include <vector>

namespace lightlink {

// RPC Request
struct RPCRequest {
    std::string id;
    std::string method;
    std::map<std::string, std::string> args;
};

// RPC Response
struct RPCResponse {
    std::string id;
    bool success;
    std::map<std::string, std::string> result;
    std::string error;
};

// Method metadata
struct MethodMetadata {
    std::string description;
    std::map<std::string, std::string> parameters;
};

} // namespace lightlink
```

**Step 4: Commit**

```bash
git add sdk/cpp/include/lightlink/
git commit -m "feat(cpp): add SDK header files"
```

---

## Task 2: Complete Client Implementation

**Files:**
- Modify: `sdk/cpp/src/client.cpp`

**Step 1: Update client.cpp to match header**

Ensure all methods declared in header are implemented.
The current implementation has most functionality but needs to match the header interface.

**Step 2: Add missing methods**

```cpp
#include "lightlink/client.hpp"
#include "lightlink/types.hpp"
#include <nats.hpp>

namespace lightlink {

// Complete implementation of all methods
// (Most already exist, just need to match header)

} // namespace lightlink
```

**Step 3: Update CMakeLists.txt**

```cmake
cmake_minimum_required(VERSION 3.15)
project(lightlink_cpp VERSION 1.0.0 LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# Find NATS
find_package(nats REQUIRED)

# Create library
add_library(lightlink SHARED
    src/client.cpp
)

target_include_directories(lightlink PUBLIC
    ${CMAKE_CURRENT_SOURCE_DIR}/include
)

target_link_libraries(lightlink PUBLIC
    nats::nats
)

# Examples
add_subdirectory(examples)
```

**Step 4: Test build**

Run: `cd sdk/cpp && mkdir -p build && cd build && cmake .. && make`
Expected: Builds successfully

**Step 5: Commit**

```bash
git add sdk/cpp/
git commit -m "feat(cpp): complete client implementation"
```

---

## Task 3: Implement Service Class

**Files:**
- Create: `sdk/cpp/src/service.cpp`

**Step 1: Implement service.cpp**

```cpp
#include "lightlink/service.hpp"
#include "lightlink/types.hpp"
#include <nats.hpp>
#include <chrono>
#include <thread>

namespace lightlink {

class Service::Impl {
public:
    std::string name_;
    std::string nats_url_;
    TLSConfig tls_config_;
    std::unique_ptr<nats::Connection> nc;
    std::map<std::string, RPCHandler> handlers_;
    std::unique_ptr<std::thread> heartbeat_thread_;
    std::atomic<bool> running_;

    void send_heartbeat() {
        // Send heartbeat to $LL.heartbeat.{service_name}
        // Implementation similar to Go SDK
    }
};

Service::Service(const std::string& name, const std::string& nats_url, const TLSConfig* tls_config)
    : name_(name), impl_(std::make_unique<Impl>()) {
    impl_->name_ = name;
    impl_->nats_url_ = nats_url;
    if (tls_config) {
        impl_->tls_config_ = *tls_config;
    }
    impl_->running_ = false;
}

Service::~Service() {
    stop();
}

void Service::register_method(const std::string& method, RPCHandler handler) {
    impl_->handlers_[method] = handler;
}

bool Service::start() {
    try {
        nats::Options options;
        options.setName("LightLink C++ Service: " + name_);
        options.setUrl(impl_->nats_url_);

        impl_->nc = std::make_unique<nats::Connection>(
            nats::Connection::connect(impl_->nats_url_, options)
        );

        // Subscribe to RPC requests
        std::string subject = "$SRV." + name_ + ".*";
        impl_->nc->subscribe(subject, [this](nats::Message& msg) {
            // Handle RPC request
            // Parse method from subject
            // Call registered handler
            // Send response
        });

        impl_->running_ = true;

        // Start heartbeat thread
        impl_->heartbeat_thread_ = std::make_unique<std::thread>([this]() {
            while (impl_->running_) {
                impl_->send_heartbeat();
                std::this_thread::sleep_for(std::chrono::seconds(30));
            }
        });

        return true;
    } catch (const std::exception& e) {
        return false;
    }
}

void Service::stop() {
    impl_->running_ = false;
    if (impl_->heartbeat_thread_ && impl_->heartbeat_thread_->joinable()) {
        impl_->heartbeat_thread_->join();
    }
    impl_->nc->close();
}

bool Service::is_running() const {
    return impl_->running_;
}

} // namespace lightlink
```

**Step 2: Update CMakeLists.txt**

```cmake
add_library(lightlink SHARED
    src/client.cpp
    src/service.cpp
)
```

**Step 3: Commit**

```bash
git add sdk/cpp/src/service.cpp sdk/cpp/CMakeLists.txt
git commit -m "feat(cpp): add service implementation"
```

---

## Task 4: Create C++ Provider Example

**Files:**
- Create: `light_link_platform/examples/provider/cpp/math-service/`
- Create: `light_link_platform/examples/provider/cpp/math-service/main.cpp`
- Create: `light_link_platform/examples/provider/cpp/math-service/CMakeLists.txt`

**Step 1: Create provider example**

```cpp
#include <lightlink/service.hpp>
#include <iostream>
#include <cmath>

using namespace lightlink;

int main() {
    std::cout << "=== C++ Math Service ===" << std::endl;

    std::string nats_url = "nats://172.18.200.47:4222";

    // Create service
    Service svc("math-service-cpp", nats_url);

    // Register methods
    svc.register_method("add", [](const auto& args) {
        int a = std::stoi(args.at("a"));
        int b = std::stoi(args.at("b"));
        return std::map<std::string, std::string>{
            {"result", std::to_string(a + b)}
        };
    });

    svc.register_method("multiply", [](const auto& args) {
        int a = std::stoi(args.at("a"));
        int b = std::stoi(args.at("b"));
        return std::map<std::string, std::string>{
            {"result", std::to_string(a * b)}
        };
    });

    svc.register_method("power", [](const auto& args) {
        double base = std::stod(args.at("base"));
        double exp = std::stod(args.at("exp"));
        return std::map<std::string, std::string>{
            {"result", std::to_string(std::pow(base, exp))}
        };
    });

    // Start service
    if (!svc.start()) {
        std::cerr << "Failed to start service" << std::endl;
        return 1;
    }

    std::cout << "Math service started" << std::endl;
    std::cout << "Press Ctrl+C to stop..." << std::endl;

    // Keep running
    std::this_thread::sleep_for(std::chrono::hours(24));

    svc.stop();
    return 0;
}
```

**Step 2: Create CMakeLists.txt**

```cmake
cmake_minimum_required(VERSION 3.15)
project(math-service-cpp)

set(CMAKE_CXX_STANDARD 17)

# Find LightLink SDK
find_package(lightlink REQUIRED HINTS ../../../../../sdk/cpp/build)

add_executable(math-service-cpp main.cpp)

target_link_libraries(math-service-cpp PRIVATE lightlink)
```

**Step 3: Commit**

```bash
git add light_link_platform/examples/provider/cpp/math-service/
git commit -m "feat(cpp): add math service provider example"
```

---

## Task 5: Create C++ Caller Example

**Files:**
- Create: `light_link_platform/examples/caller/cpp/call-math-service/`
- Create: `light_link_platform/examples/caller/cpp/call-math-service/main.cpp`
- Create: `light_link_platform/examples/caller/cpp/call-math-service/CMakeLists.txt`

**Step 1: Create caller example**

```cpp
#include <lightlink/client.hpp>
#include <iostream>
#include <thread>
#include <chrono>

using namespace lightlink;

int main() {
    std::cout << "=== C++ Caller Demo ===" << std::endl;

    std::string nats_url = "nats://172.18.200.47:4222";

    // Discover certificates
    auto certs = discover_client_certs();
    TLSConfig tls_config;
    tls_config.cert_file = certs.cert_file;
    tls_config.key_file = certs.key_file;
    tls_config.ca_file = certs.ca_file;

    // Create client
    Client client(nats_url, &tls_config);

    if (!client.connect()) {
        std::cerr << "Failed to connect" << std::endl;
        return 1;
    }

    std::cout << "Connected" << std::endl;

    // Wait a bit for service to be ready
    std::this_thread::sleep_for(std::chrono::seconds(2));

    // Call math service
    auto result1 = client.call("math-service-cpp", "add", {
        {"a", "10"},
        {"b", "20"}
    });
    std::cout << "add(10, 20) = " << result1["result"] << std::endl;

    auto result2 = client.call("math-service-cpp", "multiply", {
        {"a", "5"},
        {"b", "6"}
    });
    std::cout << "multiply(5, 6) = " << result2["result"] << std::endl;

    auto result3 = client.call("math-service-cpp", "power", {
        {"base", "2"},
        {"exp", "10"}
    });
    std::cout << "power(2, 10) = " << result3["result"] << std::endl;

    client.close();
    return 0;
}
```

**Step 2: Commit**

```bash
git add light_link_platform/examples/caller/cpp/call-math-service/
git commit -m "feat(cpp): add caller example"
```

---

## Task 6: Create C++ PubSub Example

**Files:**
- Create: `light_link_platform/examples/notify/cpp/pubsub-demo/`
- Create: `light_link_platform/examples/notify/cpp/pubsub-demo/main.cpp`

**Step 1: Create pubsub example**

```cpp
#include <lightlink/client.hpp>
#include <iostream>
#include <thread>
#include <chrono>

using namespace lightlink;

int main() {
    std::cout << "=== C++ PubSub Demo ===" << std::endl;

    std::string nats_url = "nats://172.18.200.47:4222";

    auto certs = discover_client_certs();
    TLSConfig tls_config;
    tls_config.cert_file = certs.cert_file;
    tls_config.key_file = certs.key_file;
    tls_config.ca_file = certs.ca_file;

    Client client(nats_url, &tls_config);

    if (!client.connect()) {
        std::cerr << "Failed to connect" << std::endl;
        return 1;
    }

    // Subscribe
    std::string subject = "demo.cpp.pubsub";
    std::string sub_id = client.subscribe(subject, [](const auto& data) {
        std::cout << "Received: " << data.at("message") << std::endl;
    });

    std::cout << "Subscribed to: " << subject << std::endl;

    // Publish
    for (int i = 1; i <= 3; i++) {
        client.publish(subject, {
            {"message", "Hello from C++ #" + std::to_string(i)},
            {"count", std::to_string(i)}
        });
        std::this_thread::sleep_for(std::chrono::milliseconds(500));
    }

    // Wait for messages
    std::this_thread::sleep_for(std::chrono::seconds(2));

    client.close();
    return 0;
}
```

**Step 2: Commit**

```bash
git add light_link_platform/examples/notify/cpp/pubsub-demo/
git commit -m "feat(cpp): add pubsub example"
```

---

## Task 7: Update Documentation

**Files:**
- Modify: `light_link_platform/examples/provider/README.md`
- Modify: `light_link_platform/examples/caller/README.md`
- Modify: `light_link_platform/examples/notify/README.md`

**Step 1: Add C++ entries to all READMEs**

Provider README:
```markdown
| C++ | math-service-cpp | add, multiply, power |
```

Caller README:
```markdown
| C++ | call-math-service | ✅ |
```

Notify README:
```markdown
| C++ | pubsub-demo | ✅ |
```

**Step 2: Create C++ README**

Create `light_link_platform/examples/provider/cpp/README.md`:

```markdown
# C++ Examples

## Math Service

A simple math service demonstrating C++ provider functionality.

### Building

```bash
cd math-service
mkdir build && cd build
cmake ..
make
```

### Running

```bash
./math-service-cpp
```

### Requirements

- C++17 compatible compiler
- NATS C++ client
- CMake 3.15+
```

**Step 3: Commit**

```bash
git add light_link_platform/examples/
git commit -m "docs(cpp): update READMEs with C++ examples"
```

---

## Testing Strategy

### Prerequisites
- C++17 compiler (g++, clang, MSVC)
- NATS C++ client installed
- CMake 3.15+
- NATS server running

### Build SDK

```bash
cd sdk/cpp
mkdir build && cd build
cmake ..
make
```

### Build and Run Examples

```bash
# Provider
cd light_link_platform/examples/provider/cpp/math-service
mkdir build && cd build
cmake ..
make
./math-service-cpp

# Caller (in another terminal)
cd light_link_platform/examples/caller/cpp/call-math-service
mkdir build && cd build
cmake ..
make
./call-math-service

# PubSub
cd light_link_platform/examples/notify/cpp/pubsub-demo
mkdir build && cd build
cmake ..
make
./pubsub-demo
```

---

## Dependencies

- C++17 or later
- NATS C++ client (nats.cpp)
- CMake 3.15+
- NATS server with JetStream enabled

---

## Known Limitations

This is a basic C++ implementation. Advanced features not yet implemented:

- File transfer (Object Store)
- Backup functionality
- State management (KV)
- Full metadata support
- Advanced TLS configuration

These can be added in future iterations based on demand.

---

## Related Plans

- P0: C# Client restoration (higher priority for most users)
- P1: Python/C# examples (more commonly used languages)

---

## Acceptance Testing via Management Platform

**IMPORTANT:** All development plans must be verified through the management platform.

### Step 1: Start Management Platform Backend

```bash
cd light_link_platform/manager_base/server
go run main.go
```

Wait for the backend server to start.

### Step 2: Start Management Platform Frontend

```bash
cd light_link_platform/manager_base/web
npm run dev
```

Wait for the frontend to start.

### Step 3: Open Browser and Verify

1. Open browser to the frontend URL
2. Navigate to the Services section
3. Verify C++ services:
   - C++ Provider (math-service-cpp) appears in service list
   - C++ Caller can invoke RPC methods
   - C++ PubSub sends/receives messages

### Step 4: Test C++ Integration Flow

1. Start C++ math service provider
2. Start C++ caller example
3. Start C++ pubsub example
4. Observe in management platform:
   - Service registration for all C++ examples
   - RPC calls between C++ services
   - PubSub messages from C++ clients

### Step 5: Capture Evidence

Take screenshots showing C++ services integrated in the management platform.
