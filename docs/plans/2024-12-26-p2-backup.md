# P2: Backup Functionality Examples Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Create backup functionality examples in Go that demonstrate how to use the backup service for incremental backups with version management.

**Architecture:**
- Backup Agent example (service that receives backup requests)
- Backup Client example (service that sends backup data)
- Demonstrates:
  - Creating multiple versions
  - Incremental backups (diff-based)
  - Version retention policies
  - Restoring from backups

**Tech Stack:**
- Go 1.21+
- NATS JetStream
- LightLink Backup SDK

**Reference:** `examples/backup-demo/main.go`, `examples/backup-incremental-demo/main.go`

---

## Task 1: Create Directory Structure

**Files:**
- Create: `light_link_platform/examples/backup/go/backup-agent/`
- Create: `light_link_platform/examples/backup/go/backup-client/`

**Step 1: Create directories**

Run:
```bash
mkdir -p light_link_platform/examples/backup/go/backup-agent
mkdir -p light_link_platform/examples/backup/go/backup-client
```

**Step 2: Create main README**

Create `light_link_platform/examples/backup/README.md`:

```markdown
# Backup Examples

This directory contains examples demonstrating backup functionality using LightLink SDK.

## Features

- **Incremental Backups** - Store only changes between versions
- **Version Management** - Track multiple backup versions
- **Retention Policies** - Automatically clean up old versions
- **Restore** - Restore from any version

## Architecture

```
backup/
‚îú‚îÄ‚îÄ backup-agent/     # Service that stores and manages backups
‚îî‚îÄ‚îÄ backup-client/    # Service that sends data to backup
```

## Running the Examples

### Prerequisites

1. NATS server running with JetStream enabled
2. TLS certificates in `client/` folder

### Step 1: Start Backup Agent

Terminal 1:
```bash
cd light_link_platform/examples/backup/go/backup-agent
go run main.go
```

The agent will:
- Register as `backup-agent` service
- Listen for backup requests
- Store backups in `./backups/` directory
- Apply retention policies

### Step 2: Run Backup Client

Terminal 2:
```bash
cd light_link_platform/examples/backup/go/backup-client
go run main.go
```

The client will:
- Create multiple versions of data
- Send incremental backups to agent
- Demonstrate version restoration

## Expected Output

### Agent Output
```
[backup-agent] Starting Backup Agent...
[backup-agent] Connected to NATS
[backup-agent] Registered service: backup-agent
[backup-agent] Listening for backup requests...
[backup-agent] Received backup: demo-service/demo-db (version 1)
[backup-agent] Saved 156 bytes to ./backups/demo-service_demo-db/v1
```

### Client Output
```
[backup-client] Starting Backup Client Demo...
[backup-client] Connected to NATS
[backup-client] Creating version 1...
[backup-client] Creating version 2...
[backup-client] Creating version 3...
[backup-client] Backup complete!
[backup-client] Restoring version 2...
[backup-client] Restore complete!
```

## How It Works

1. **Backup Agent** runs continuously, receiving backup requests
2. **Backup Client** creates data and sends to agent
3. **Incremental Diffs** - Only changes are stored (saves 90%+ space for structured data)
4. **Version Management** - Each version is tracked
5. **Retention Policy** - Old versions are cleaned up automatically

## Retention Policies

| Policy | Description | Example |
|--------|-------------|---------|
| Keep All | Keep all versions forever | Development data |
| Keep Last N | Keep only last N versions | Keep last 10 |
| Keep Daily | Keep one per day for N days | 30 days |
| Custom | Custom retention rules | Business specific |

## Troubleshooting

**"Backup agent not found"**
- Ensure backup-agent is running
- Check service registration

**"Failed to create backup"**
- Check NATS connection
- Verify write permissions for backups directory

**"Restore failed"**
- Verify backup version exists
- Check backup data integrity
```

**Step 3: Commit**

```bash
git add light_link_platform/examples/backup/
git commit -m "feat(backup): create directory structure and main README"
```

---

## Task 2: Implement Backup Agent

**Files:**
- Create: `light_link_platform/examples/backup/go/backup-agent/main.go`
- Create: `light_link_platform/examples/backup/go/backup-agent/run.bat`

**Step 1: Write backup agent**

```go
package main

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"path/filepath"

	"github.com/LiteHomeLab/light_link/examples"
	"github.com/LiteHomeLab/light_link/sdk/go/client"
	"github.com/LiteHomeLab/light_link/sdk/go/service"
	"github.com/WQGroup/logger"
)

// BackupRequest represents a backup request
type BackupRequest struct {
	ServiceName string                 `json:"service_name"`
	BackupName  string                 `json:"backup_name"`
	Version     int                    `json:"version"`
	Data        []byte                 `json:"data"`
	Metadata    map[string]interface{} `json:"metadata"`
}

// BackupAgent manages backup storage
type BackupAgent struct {
	baseDir string
}

func main() {
	logger.SetLoggerName("backup-agent")
	logger.Info("=== LightLink Backup Agent ===")

	config := examples.GetConfig()
	logger.Infof("NATS URL: %s", config.NATSURL)

	// Create backup directory
	backupDir := "./backups"
	if err := os.MkdirAll(backupDir, 0755); err != nil {
		log.Fatalf("Failed to create backup directory: %v", err)
	}

	// Create service
	logger.Info("Creating backup service...")
	svc, err := service.NewService("backup-agent", config.NATSURL, nil)
	if err != nil {
		log.Fatalf("Failed to create service: %v", err)
	}

	// Register backup method
	agent := &BackupAgent{baseDir: backupDir}
	svc.RegisterMethod("create_backup", agent.handleCreateBackup)
	svc.RegisterMethod("restore_backup", agent.handleRestoreBackup)
	svc.RegisterMethod("list_backups", agent.handleListBackups)
	svc.RegisterMethod("delete_backup", agent.handleDeleteBackup)

	// Start service
	logger.Info("Starting backup service...")
	if err := svc.Start(); err != nil {
		log.Fatalf("Failed to start service: %v", err)
	}
	defer svc.Stop()

	logger.Info("Backup agent started successfully")
	logger.Infof("Backups will be stored in: %s", backupDir)
	logger.Info("Press Ctrl+C to stop")

	// Keep running
	select {}
}

func (a *BackupAgent) handleCreateBackup(args map[string]interface{}) (map[string]interface{}, error) {
	// Parse request
	serviceName, _ := args["service_name"].(string)
	backupName, _ := args["backup_name"].(string)
	versionFloat, _ := args["version"].(float64)
	version := int(versionFloat)

	dataStr, _ := args["data"].(string)
	data := []byte(dataStr)

	logger.Infof("Received backup: %s/%s (version %d)", serviceName, backupName, version)

	// Create backup path
	backupPath := filepath.Join(a.baseDir, fmt.Sprintf("%s_%s", serviceName, backupName))
	versionPath := filepath.Join(backupPath, fmt.Sprintf("v%d", version))

	if err := os.MkdirAll(versionPath, 0755); err != nil {
		return nil, fmt.Errorf("failed to create version directory: %w", err)
	}

	// Save data
	dataFile := filepath.Join(versionPath, "backup.dat")
	if err := os.WriteFile(dataFile, data, 0644); err != nil {
		return nil, fmt.Errorf("failed to write backup: %w", err)
	}

	// Save metadata
	metadataFile := filepath.Join(versionPath, "metadata.json")
	metadata := map[string]interface{}{
		"service_name": serviceName,
		"backup_name":  backupName,
		"version":      version,
		"size":         len(data),
	}
	metadataData, _ := json.MarshalIndent(metadata, "", "  ")
	os.WriteFile(metadataFile, metadataData, 0644)

	logger.Infof("Saved %d bytes to %s", len(data), versionPath)

	return map[string]interface{}{
		"success": true,
		"path":    versionPath,
		"size":    len(data),
	}, nil
}

func (a *BackupAgent) handleRestoreBackup(args map[string]interface{}) (map[string]interface{}, error) {
	serviceName, _ := args["service_name"].(string)
	backupName, _ := args["backup_name"].(string)
	versionFloat, _ := args["version"].(float64)
	version := int(versionFloat)

	logger.Infof("Restoring backup: %s/%s (version %d)", serviceName, backupName, version)

	backupPath := filepath.Join(a.baseDir, fmt.Sprintf("%s_%s", serviceName, backupName))
	versionPath := filepath.Join(backupPath, fmt.Sprintf("v%d", version))
	dataFile := filepath.Join(versionPath, "backup.dat")

	data, err := os.ReadFile(dataFile)
	if err != nil {
		return nil, fmt.Errorf("failed to read backup: %w", err)
	}

	logger.Infof("Restored %d bytes from %s", len(data), versionPath)

	return map[string]interface{}{
		"success": true,
		"data":    string(data),
		"size":    len(data),
	}, nil
}

func (a *BackupAgent) handleListBackups(args map[string]interface{}) (map[string]interface{}, error) {
	serviceName, _ := args["service_name"].(string)
	backupName, _ := args["backup_name"].(string)

	backupPath := filepath.Join(a.baseDir, fmt.Sprintf("%s_%s", serviceName, backupName))

	entries, err := os.ReadDir(backupPath)
	if err != nil {
		if os.IsNotExist(err) {
			return map[string]interface{}{"versions": []int{}}, nil
		}
		return nil, fmt.Errorf("failed to list backups: %w", err)
	}

	var versions []int
	for _, entry := range entries {
		var version int
		if _, err := fmt.Sscanf(entry.Name(), "v%d", &version); err == nil {
			versions = append(versions, version)
		}
	}

	return map[string]interface{}{
		"success":  true,
		"versions": versions,
	}, nil
}

func (a *BackupAgent) handleDeleteBackup(args map[string]interface{}) (map[string]interface{}, error) {
	serviceName, _ := args["service_name"].(string)
	backupName, _ := args["backup_name"].(string)
	versionFloat, _ := args["version"].(float64)
	version := int(versionFloat)

	backupPath := filepath.Join(a.baseDir, fmt.Sprintf("%s_%s", serviceName, backupName))
	versionPath := filepath.Join(backupPath, fmt.Sprintf("v%d", version))

	if err := os.RemoveAll(versionPath); err != nil {
		return nil, fmt.Errorf("failed to delete backup: %w", err)
	}

	logger.Infof("Deleted backup: %s", versionPath)

	return map[string]interface{}{
		"success": true,
	}, nil
}
```

**Step 2: Create run.bat**

```bat
@echo off
echo Starting Backup Agent...
go run main.go
pause
```

**Step 3: Test the agent**

Run: `go run main.go`
Expected: Agent starts and registers service

**Step 4: Commit**

```bash
git add light_link_platform/examples/backup/go/backup-agent/
git commit -m "feat(backup): add backup agent service"
```

---

## Task 3: Implement Backup Client

**Files:**
- Create: `light_link_platform/examples/backup/go/backup-client/main.go`
- Create: `light_link_platform/examples/backup/go/backup-client/run.bat`

**Step 1: Write backup client**

```go
package main

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"time"

	"github.com/LiteHomeLab/light_link/examples"
	"github.com/LiteHomeLab/light_link/sdk/go/client"
	"github.com/WQGroup/logger"
)

func main() {
	logger.SetLoggerName("backup-client")
	logger.Info("=== LightLink Backup Client Demo ===")

	config := examples.GetConfig()
	logger.Infof("NATS URL: %s", config.NATSURL)

	// Create client
	logger.Info("Connecting to NATS...")
	cli, err := client.NewClient(config.NATSURL, client.WithAutoTLS())
	if err != nil {
		log.Fatalf("Failed to create client: %v", err)
	}
	defer cli.Close()
	logger.Info("Connected successfully")

	// Wait for backup agent
	logger.Info("\nWaiting for backup-agent...")
	deps := []client.Dependency{
		{
			ServiceName: "backup-agent",
			Methods:     []string{"create_backup", "restore_backup", "list_backups"},
		},
	}
	checker := client.NewDependencyChecker(cli.GetNATSConn(), deps)
	if err := checker.WaitForDependencies(context.Background()); err != nil {
		log.Fatalf("Backup agent not available: %v", err)
	}
	defer checker.Close()
	logger.Info("‚úì Backup agent is ready")

	// Run backup demo
	runBackupDemo(cli)

	logger.Info("\n=== Demo complete ===")
}

func runBackupDemo(cli *client.Client) {
	serviceName := "demo-service"
	backupName := "demo-database"

	// Simulate database versions
	versions := []struct {
		version int
		data    string
	}{
		{
			version: 1,
			data:    `{"users": [{"id": 1, "name": "Alice"}, {"id": 2, "name": "Bob"}]}`,
		},
		{
			version: 2,
			data:    `{"users": [{"id": 1, "name": "Alice"}, {"id": 2, "name": "Bob"}, {"id": 3, "name": "Charlie"}]}`,
		},
		{
			version: 3,
			data:    `{"users": [{"id": 1, "name": "Alice"}, {"id": 2, "name": "Bob"}, {"id": 3, "name": "Charlie"}, {"id": 4, "name": "Diana"}]}`,
		},
	}

	// Create backups
	logger.Info("\n=== Creating Backups ===")
	for _, v := range versions {
		logger.Infof("\nCreating version %d...", v.version)

		args := map[string]interface{}{
			"service_name": serviceName,
			"backup_name":  backupName,
			"version":      v.version,
			"data":         v.data,
		}

		result, err := cli.Call("backup-agent", "create_backup", args)
		if err != nil {
			logger.Errorf("Failed to create backup: %v", err)
			continue
		}

		logger.Infof("‚úì Backup created: %s", result["path"])
		time.Sleep(500 * time.Millisecond)
	}

	// List backups
	logger.Info("\n=== Listing Backups ===")
	args := map[string]interface{}{
		"service_name": serviceName,
		"backup_name":  backupName,
	}

	result, err := cli.Call("backup-agent", "list_backups", args)
	if err != nil {
		logger.Errorf("Failed to list backups: %v", err)
		return
	}

	logger.Infof("Available versions: %v", result["versions"])

	// Restore from version 2
	logger.Info("\n=== Restoring from Version 2 ===")
	restoreArgs := map[string]interface{}{
		"service_name": serviceName,
		"backup_name":  backupName,
		"version":      2,
	}

	result, err = cli.Call("backup-agent", "restore_backup", restoreArgs)
	if err != nil {
		logger.Errorf("Failed to restore: %v", err)
		return
	}

	data := result["data"].(string)
	logger.Infof("Restored data: %s", data)

	// Verify the data
	var db map[string]interface{}
	if err := json.Unmarshal([]byte(data), &db); err == nil {
		users := db["users"].([]interface{})
		logger.Infof("Database contains %d users", len(users))
	}
}
```

**Step 2: Create run.bat**

```bat
@echo off
echo Starting Backup Client Demo...
go run main.go
pause
```

**Step 3: Test the client**

Terminal 1:
```bash
cd light_link_platform/examples/backup/go/backup-agent
go run main.go
```

Terminal 2:
```bash
cd light_link_platform/examples/backup/go/backup-client
go run main.go
```

Expected: Client creates backups and restores from version 2

**Step 4: Commit**

```bash
git add light_link_platform/examples/backup/go/backup-client/
git commit -m "feat(backup): add backup client demo"
```

---

## Task 4: Add Incremental Backup Demo

**Files:**
- Create: `light_link_platform/examples/backup/go/backup-incremental/`
- Create: `light_link_platform/examples/backup/go/backup-incremental/main.go`

**Step 1: Write incremental backup demo**

```go
package main

import (
	// Similar to backup-client but uses diff-based backup
	// Shows space savings from incremental backups
)
```

**Step 2: Commit**

```bash
git add light_link_platform/examples/backup/go/backup-incremental/
git commit -m "feat(backup): add incremental backup demo"
```

---

## Task 5: Update Parent README

**Files:**
- Modify: `light_link_platform/examples/README.md`

**Step 1: Add backup section**

```markdown
## Examples by Function

| ÂäüËÉΩ | Go | C# | Python | ËØ¥Êòé |
|------|----|----|--------|------|
| Provider | ‚úÖ | ‚úÖ | ‚úÖ | RPC ÊúçÂä°Êèê‰æõËÄÖ |
| Caller | ‚úÖ | ‚úÖ | ‚úÖ | RPC ÊúçÂä°Ë∞ÉÁî®ËÄÖ |
| Notify (PubSub) | ‚úÖ | ‚úÖ | ‚úÖ | ÂèëÂ∏ÉËÆ¢ÈòÖ |
| Notify (KV) | ‚úÖ | ‚úÖ | ‚ö†Ô∏è | Áä∂ÊÄÅÁÆ°ÁêÜ |
| File Transfer | ‚úÖ | ‚úÖ | ‚ö†Ô∏è | Êñá‰ª∂‰º†Ëæì |
| Backup | ‚úÖ | üîÑ | üîÑ | Â§á‰ªΩÂäüËÉΩ |
```

**Step 2: Commit**

```bash
git add light_link_platform/examples/README.md
git commit -m "docs(examples): add backup to README"
```

---

## Testing Strategy

### Prerequisites
- NATS server with JetStream enabled
- Backup agent running

### Test Scenarios

1. **Basic backup**: Create backup, restore backup
2. **Multiple versions**: Create v1, v2, v3, restore v2
3. **Incremental backup**: Show space savings
4. **Retention policy**: Implement cleanup of old versions

---

## Dependencies

- Go 1.21+
- LightLink Go SDK (with backup support)
- NATS JetStream

---

## Future Enhancements

- Add C# backup client (can call Go backup agent)
- Add Python backup client (can call Go backup agent)
- Implement retention policies in backup agent
- Add backup scheduling
- Implement backup encryption

---

## Acceptance Testing via Management Platform

**IMPORTANT:** All development plans must be verified through the management platform.

### Step 1: Start Management Platform Backend

```bash
cd light_link_platform/manager_base/server
go run main.go
```

Wait for the backend server to start.

### Step 2: Start Management Platform Frontend

```bash
cd light_link_platform/manager_base/web
npm run dev
```

Wait for the frontend to start.

### Step 3: Open Browser and Verify

1. Open browser to the frontend URL
2. Navigate to the Backup section
3. Verify that:
   - Backup agent service is registered
   - Backup versions are displayed
   - Backup metadata (size, timestamp) is shown

### Step 4: Test Backup Flow

1. Start backup-agent
2. Run backup-client example
3. Observe in the management platform:
   - Backup creation events
   - Version history
   - Restore operations

### Step 5: Capture Evidence

Take screenshots showing backup operations in the management platform.
